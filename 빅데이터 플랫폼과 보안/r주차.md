![alt text](image-14.png)

### 버킷의 개수 규칙

1. **하나 또는 두 개의 버킷만 가질 수 있다**:
   - 같은 크기의 1의 개수를 가지는 버킷은 `최대 두 개`까지만 존재할 수 있다.
   - 예를 들어, 2개의 1을 가지는 버킷이 세 개가 생기는 경우, `가장 오래된 버킷은 사라지고` 두 개만 남는다.
   - 1의 개수는 2의 제곱수이어야 하므로, 버킷에 들어갈 수 있는 1의 개수는 1, 2, 4, 8, 16 등으로 정해진다.

2. **버킷은 타임스탬프가 겹치지 않는다**:
   - 각 버킷은 고유한 구간을 나타내므로, 두 버킷이 같은 타임스탬프를 공유할 수 없다.
   - 즉, 각 버킷이 다루는 시간 구간은 서로 겹치지 않도록 유지된다.

3. **버킷은 크기 순으로 정렬된다**:
   - 버킷은 크기(즉, `버킷 안에 있는 1의 개수`)에 따라 정렬된다.
   - 이전의 버킷이 이후의 버킷보다 작지 않다: 이 말은 버킷의 크기가 시간이 지남에 따라 작아지지 않는다는 뜻이다.
   - 예를 들어, 시간상 앞에 있는 버킷이 뒤에 있는 버킷보다 크거나 같은 개수의 1을 포함하게 된다.

4. **버킷은 일정 시간이 지나면 사라진다**:
   - 버킷의 끝나는 시간이 N보다 큰 시간이 되면 그 버킷은 스트림에서 사라진다.
   - 여기서 N은 현재 DGIM이 추적하는 최근 스트림의 길이이다.
   - 즉, N이 100이라면, 100개의 비트를 넘은 오래된 버킷은 더 이상 필요 없으므로 버려진다.

![alt text](image-15.png)

### 새로운 비트가 들어올 때의 처리 규칙

1. **가장 오래된 버킷 삭제**:
   - 새로운 비트가 들어오면, 끝나는 시간이 현재 시간으로부터 N 시간 단위 이전인 가장 오래된 버킷을 삭제한다.

2. **두 가지 경우**:
   - 현재 비트가 0인 경우:
     - 다른 변경 사항은 필요 없다.
   - 현재 비트가 1인 경우:
     1. **새 버킷 생성**:
        - `크기가 1인 새로운 버킷을 생성`한다.
        - 끝나는 타임스탬프는 현재 시간으로 설정한다.
     2. **버킷 병합**:
        - 만약 크기가 1인 버킷이 세 개가 되면, 가장 오래된 두 개를 병합하여 크기가 2인 버킷을 만든다.
        - 만약 크기가 2인 버킷이 세 개가 되면, 가장 오래된 두 개를 병합하여 크기가 4인 버킷을 만든다.
        - 이 과정을 `재귀적으로 적용`한다.

![alt text](image-16.png)




![alt text](image-17.png)

### 최근 N 비트에서 1의 개수를 추정하는 방법

1. **모든 버킷의 크기를 합산**:
   - 마지막 버킷을 제외한 모든 버킷의 크기를 합산한다.
   - 여기서 "크기"는 버킷 안에 있는 1의 개수를 의미한다.

2. **마지막 버킷의 절반 크기 추가**:
   - 마지막 버킷의 크기의 절반을 더한다.

### 주의사항
- 마지막 버킷의 1 중 몇 개가 원하는 윈도우 내에 있는지 정확히 알 수 없다.
- 따라서 마지막 버킷의 크기의 절반을 더하는 것은 `근사치`를 구하는 방법이다.

### 오차가 50%인 이유와 실제 합계 계산

1. **오차 발생**:
   - 마지막 버킷의 크기를 2^r이라고 가정한다.
   - 이 마지막 버킷은 알고리즘이 현재 처리 중인 비트 스트림에서 가장 최근에 추가된 큰 구간을 나타낸다.
   - 마지막 버킷의 정확한 1의 개수를 알 수 없지만, `버킷의 크기만큼의 1을 포함하고 있을 것으로 추정`한다.
   - 이 추정이 과대평가될 수 있는 이유는 마지막 버킷이 언제 시작했는지 정확히 알 수 없기 때문이다. 이 버킷의 시작 시점 이전에 일부 0이 포함되었을 수도 있다.
   - 오차는 이 버킷의 절반에 해당하는 **최대 2^r−1**이다. 이는 마지막 버킷에 1이 아닌 0들이 절반만큼 포함되어 있을 때 발생하는 `최악의 경우`이다.

2. **왜 작은 버킷들이 존재해야 하는가**:
   - DGIM 알고리즘의 버킷 구조는 1의 개수가 2의 제곱수로 구성된다. 즉, 버킷은 크기 1, 2, 4, 8, ...과 같은 패턴으로 생성된다.
   - 각 크기의 버킷은 최대 2개까지만 존재할 수 있다. 동일한 크기의 버킷이 3개가 생길 경우 가장 오래된 버킷이 삭제된다.
   - 최신 버킷이 2^r 크기의 버킷이므로, 그 이전에는 적어도 하나 이상의 더 작은 버킷이 있어야 한다.
   - 알고리즘의 규칙에 따르면, 마지막으로 추가된 버킷이 2^r 크기를 가지면, 그 이전 단계에서는 2^(r−1), 2^(r−2), ..., 1 크기의 버킷들이 반드시 존재해야 한다.
   - 예를 들어, 크기 2^r의 버킷이 추가되기 전에, 2^(r−1) 크기의 버킷이 2개 이상 생겼다면, 그 중 가장 오래된 버킷이 제거되고 새로운 2^r 크기의 버킷이 만들어진다.

3. **실제 합계 계산**:
   - 작은 버킷들이 `반드시 하나 이상 존재`하기 때문에, 최소 합계는 1 + 2 + 4 + ... + 2^(r−1)이다.
   - 이 값은 수학적으로 2^r−1로 계산된다. 즉, 이 버킷들이 모두 존재할 때, 포함된 1의 개수는 최소 2^r−1이 된다.
   - 마지막 버킷에서, 우리는 그 버킷의 첫 번째 1을 추가로 고려해야 한다. 이 첫 번째 1은 가장 최근에 추가된 것이며, 따라서 최종적으로 2^r 만큼의 1이 포함될 수 있다.

### 요약

- **오차 발생**: 마지막 버킷의 크기를 알지만, 그 버킷에 정확히 몇 개의 1이 들어 있는지는 알 수 없다. 우리는 그 크기인 2^r를 바탕으로 1의 개수를 추정하며, 이 추정은 절반만큼 과대평가될 수 있다(최대 오차는 2^r−1).
- **왜 작은 버킷들이 존재해야 하는가**: DGIM 알고리즘은 각 버킷의 크기가 2의 제곱수로만 늘어나기 때문에, 마지막 버킷(2^r)을 추가하기 전에 그보다 작은 버킷들이 하나 이상 존재해야만 한다. 2^r 크기의 버킷을 만들기 위해서는 2^(r−1), 2^(r−2), ..., 크기의 버킷들이 있어야만 더 큰 버킷을 생성할 수 있기 때문이다.
- **실제 합계**: 작은 버킷들이 반드시 존재하므로, 우리는 최소한 1 + 2 + 4 + ... + 2^(r−1) 즉, 2^r−1개의 1을 가지고 있으며, 마지막 버킷의 첫 번째 1을 고려하면 합계는 2^r가 된다.

### 오차를 줄이는 방법

1. **더 많은 버킷 유지**:
   - 기본 DGIM 알고리즘에서는 각 크기(2^k)의 버킷을 1개 또는 2개만 유지한다.
   - 오차를 줄이기 위해, r-1 개 또는 r 개의 버킷을 유지할 수 있다. 여기서 r > 2이다.
   - 단, 가장 큰 크기의 버킷에서는 예외적으로 1개에서 r개 사이로 유지할 수 있다.

2. **오차가 O(1/r)로 감소**:
   - 더 많은 수의 작은 버킷을 유지함으로써 오차를 줄일 수 있다. **최대 오차는 O(1/r)**이다.

3. **오차 증명**:
   - 각 버킷이 r개까지 유지될 수 있으면, 오차가 줄어든다.
   - 버킷이 r개까지 유지되는 경우, 버킷들의 총 크기는 1 + (r−1)(2^i + 2^(i−1) + ... + 1)이다.
   - 이 식의 결과는 1 + (r−1)(2^i − 1)이다.
   - 가장 왼쪽 버킷이 단 1개의 1만 포함하는 경우가 최악이다. 이는 마지막 버킷이 시작할 때 1이 나타나는 경우로, 과대평가된 양은 2^i − 1 − 1이다.
   - 이를 통해 O(1/r)로 오차가 줄어듦을 증명할 수 있다.

4. **비트 저장과 오차의 균형**:
   - r 값을 적절히 선택함으로써, 저장해야 하는 비트 수와 오차 사이의 균형을 맞출 수 있다.

### 핵심 아이디어

- 기본 DGIM 알고리즘에서는 각 크기의 버킷을 1개 또는 2개만 유지하기 때문에, 큰 크기의 버킷들이 많이 포함될 수 있다.
- 더 많은 작은 버킷을 유지하면, 큰 버킷이 생성되기 전에 더 많은 작은 크기의 버킷을 유지할 수 있어, 마지막 버킷의 크기를 작게 유지할 수 있다.

### 세부 설명

1. **기본 DGIM에서의 버킷 관리**:
   - 기본 DGIM 알고리즘에서는 각 크기의 버킷을 최대 2개까지만 유지한다.
   - 작은 버킷들을 2개까지만 유지하기 때문에 더 큰 버킷이 빠르게 생성되고, 마지막 버킷의 크기도 커질 수 있다.

2. **더 많은 수의 작은 버킷 유지**:
   - r−1개 또는 r개의 버킷을 유지할 수 있다.
   - 작은 버킷들이 많아지면, 큰 버킷이 생성되는 속도가 느려진다. 결과적으로, 마지막 버킷의 크기가 상대적으로 더 작아질 가능성이 커진다.

3. **오차 감소 효과**:
   - 마지막 버킷의 크기가 작아지면, 그 안에 포함된 1의 개수를 추정할 때 발생하는 오차가 감소하게 된다.
   - 작은 버킷을 많이 유지하면 오차가 줄어든다.

### 최악의 경우

- 가장 왼쪽 버킷이 단 1개의 1만 포함하는 경우가 최악이다. 이는 마지막 버킷이 시작할 때 1이 나타나는 경우로, 이 경우 마지막 버킷의 시작점 1이후 모두가 0일것이다. 하지만 우리는 마지막 버킷을 다 확인할 수 없으니 마지막버킷이 다 1로 이루어 졌다 가정하고 절반값을 추정한다 따라서 이때, 오차가 최대가 된다.

### 결론

- 더 많은 수의 작은 크기의 버킷을 유지하면, 마지막에 남는 버킷의 크기가 상대적으로 작아질 가능성이 높아진다.
- 이는 마지막 버킷에 포함된 1의 개수를 추정할 때 발생하는 오차를 줄이는 방법이며, 결과적으로 DGIM 알고리즘의 전체적인 정확도를 향상시킬 수 있는 방식이다.

### 질문:

Q: "우리가 사용했던 방법을 확장하여, 마지막 k개의 비트에서 1이 몇 개인지 구할 수 있을까?" 여기서 k는 N보다 작은 범위입니다. 즉, 스트림의 마지막 k개의 비트 중에서 1이 몇 개인지 구하는 문제입니다.

### 답변:

A: 이 질문에 대한 답은 가장 먼저 k와 겹치는 버킷 B를 찾는 것입니다. 그 이후, k 이후의 더 최근 버킷들의 크기 합과 버킷 B의 절반 크기를 더하여 1의 개수를 추정할 수 있습니다.

### 단계별 설명:

1. **k와 겹치는 가장 처음 버킷 B 찾기**:
   - 최근 k개의 비트를 추적하기 위해 k와 겹치는 가장 첫 번째 버킷을 찾는다. 이 버킷은 B라고 부른다.
   - 이 버킷은 정확히 k 지점과 겹치며, 버킷의 일부는 k보다 이전의 비트에 포함될 수 있다.

2. **최근 버킷들의 크기 합 구하기**:
   - k와 겹치는 B 버킷보다 더 최근에 생성된 버킷들이 존재할 수 있다. 이 경우, 이 더 최근 버킷들의 크기 합은 모두 포함시킨다.
   - 이 버킷들은 k보다 이후의 비트들을 포함하고 있기 때문에, 1의 개수 계산에 모두 포함된다.

3. **버킷 B의 절반 크기 추가**:
   - k와 겹치는 버킷 B의 경우, 그 버킷이 k보다 더 이전의 비트들도 포함하고 있으므로, 이 버킷의 절반만 포함시킨다.
   - 마지막 버킷에 포함된 1의 정확한 개수를 알 수 없으므로, 절반만 계산에 포함시킨다.

4. **총합 계산**:
   - 최종 1의 개수는 B 버킷보다 최근의 버킷 크기들의 합과 B 버킷의 절반 크기를 더한 값으로 추정된다.

### 요약:

DGIM 알고리즘을 확장해서 최근 k개의 비트에서 1의 개수를 추정하려면, k와 겹치는 가장 처음 버킷 B를 찾고, 그 이후에 더 최근에 생성된 버킷들의 크기 합에 B 버킷의 절반 크기를 더하여 1의 개수를 추정할 수 있다.


### 질문:

Q: "스트림이 비트가 아니라 정수인 경우를 처리할 수 있을까? 그리고 `마지막 k개의 요소의 합`을 구할 수 있을까?"

### 입력:

- 양의 정수 스트림
- 우리는 마지막 k개의 요소의 합을 구하고자 한다.
- 예: Amazon에서 최근 k번의 판매 평균 가격

### 해결책:

1. **정수의 비트 처리**:
   - 모든 정수가 최대 m 비트(1 < int < 2^m)를 가진다고 가정한다.
   - 각 정수의 m 비트를 별도의 스트림으로 취급한다.

2. **DGIM 알고리즘 사용**:
   - DGIM 알고리즘을 사용하여 각 정수의 비트에서 1의 개수를 센다.

3. **합 계산**:
   - 각 비트의 추정된 개수를 사용하여 합을 계산한다.
   - 합은 다음과 같이 계산된다:
     \[
     \text{Sum} = \sum_{i=0}^{m-1} c_i \cdot 2^i
     \]
   - 여기서 \( c_i \)는 i번째 비트의 추정된 개수이다.

### 요약:

- 스트림이 비트가 아니라 정수인 경우에도 DGIM 알고리즘을 확장하여 마지막 k개의 요소의 합을 구할 수 있다.
- 각 정수의 비트를 별도의 스트림으로 취급하고, DGIM 알고리즘을 사용하여 각 비트에서 1의 개수를 센다.
- 마지막으로, 각 비트의 추정된 개수를 사용하여 합을 계산한다.

## Summary

#### 샘플링 (Sampling)
- **스트림의 고정 비율**:
  - 스트림의 일정 비율을 샘플링한다.
  - 스트림이 커짐에 따라 샘플 크기도 증가한다.
- **고정 크기 샘플**:
  - 고정된 크기의 샘플을 유지한다.
  - **저수지 샘플링 (Reservoir sampling)**을 사용한다.

#### 슬라이딩 윈도우 (Sliding Window)
- **마지막 N개의 요소에서 1의 개수 세기**:
  - DGIM 알고리즘: 지수적으로 증가하는 윈도우를 사용한다.
- **확장**:
  - 마지막 k (k < N)개의 요소에서 1의 개수 세기.
  - 마지막 N개의 요소에서 정수의 합 계산.

### 참고
- DGIM 알고리즘은 스트림 데이터에서 효율적으로 1의 개수를 세는 방법을 제공하며, 이를 확장하여 다양한 응용에 사용할 수 있다.