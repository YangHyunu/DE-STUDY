# NoSQL의 Consistency에 관한 주제

- 샤딩은 읽기에 초점, 복제는 데이터 가용성과 내구성에 초점을 두는 방식

### 데이터 분산 모델

#### 1. 샤딩 (Sharding)
- 샤딩: **읽기 성능**에 초점을 둠. 데이터를 여러 서버에 분산 저장하여 각 서버가 데이터의 일부를 담당하게 함.

#### 2. 복제 (Replication)
- 복제: 데이터 **가용성과 내구성**에 초점을 둠. 데이터를 여러 서버에 복사하여 데이터의 가용성과 내구성을 높임.

# Sharding

## 정의
- 샤딩은 데이터베이스 처리량과 성능을 개선하기 위한 확장<scail-out> 가능한 기술이다.
- 데이터를 여러 서버에 분산시키는 "(shared-nothing)" 파티셔닝 방식이다.
- 즉, 각 서버에 데이터가 중복없이 분산된어 저장된다.

## 주요 특징
- **수평적 확장성**: 거의 선형적인 확장성을 제공한다.
- **이상적인 상황**: 서로 다른 사용자가 서로 다른 서버 노드와 상호작용하여 부하를 분산한다.

## 장점
- 읽기/쓰기 작업의 높은 성능.
- 비용 효율적: 고성능 멀티-CPU 서버 대신 다중 코어를 가진 일반 서버를 활용한다.

## 단점
- 클러스터가 덜 신뢰할 수 있는 머신<성능이 낮은 개별노드>에 의존하기 때문에 복원력이 낮아진다.

## 예시
- 단일 `User` 데이터베이스 테이블을 여러 샤드로 분리:
  - **샤드 1**: 사용자 `kim`과 `lee`를 포함.
  - **샤드 2**: 사용자 `park`과 `nam`을 포함.
![alt text](image-128.png)

### 샤딩 전략
- 데이터 근접성: 데이터는 접근하는 곳에<물리적으로> 가깝게 배치.
- 부하 균등화: 모든 노드가 **균등한 부하**를 받도록 유지.
- 집계 배치: **순차적**으로 읽을 수 있는 데이터는 동일한 노드에 배치.
- 자동 샤딩: 많은 NoSQL 데이터베이스는 자동 샤딩 기능을 제공.


# Replication
- 읽기 성능증가 -> 여러 복제본에서 데이터를 읽어올 수 있으므로
- 데이터가 여러 위치에 존재하여 가용성이 높아짐 -> 데이터가 손실방지 및 복구가능
### 두 가지 접근 방식
- 마스터-슬레이브 (Master-Slave)
  - 마스터 노드가 데이터를 업데이트하고, 슬레이브 노드가 이를 복제하여 읽기 요청을 처리함.

- 피어-투-피어 (Peer-to-Peer)
  - 모든 노드가 동등한 역할을 하며, 데이터를 읽고 쓸 수 있음. 데이터는 각 노드 간에 동기화됨.

## Master
- 데이터의 위치 및 접근관리
- 데이터의 업데이트가 일어날때 마스터노드가 동작함

## Slaves
- replaction과정중에 마스터노드와 슬레이브노드가 동기화 됨
  - 마스터노드가 데이터를 업데이트 하면 이후 슬레이브 노드가 이를 복제하여 동기화함
- 마스터 노드가 만약 기능을 상실했을때, 슬레이브 노드 중 하나가 즉시 마스터 노드로 기능할 수 있다.

![alt text](image-68.png)
- 분산 즉, 병렬 처리로 데이터를 읽으므로 읽기성능이 증가함
- 반대로 쓰기(Update)의 경우 `오로지 마스터노드가 처리`하므로 속도가 느리다. 데이터가 업데이트 된 경우 마스터노드가 처리하므로 마스터 노드 자신이 데이터를 슬레이브 노드에 복제하는 과정을 동기화함

#### 장점:
  - 만약 데이터셋이 읽기 중심이라면 성능이 매우 좋다.
    - 만약 읽기 요청이 매우 많다면, 그저 슬레이브노드를 추가해주면 된다.
    - 마스터 노드가 기능을 상실하더라도, 즉시 슬레이브노드가 이를 대체할 수 있다.
#### 단점:
    - 데이터 업데이트를 마스터노드가 혼자 처리하므로 `병목현상`이 발생함
    - 변경 사항이 슬레이브 노드로 느리게 전파되어 `일관성 문제`가 발생할 수 있음
    - 쓰기 요청(업데이트)이 많은 데이터셋에는 적합하지 않음

# Pear-to-Pear Replication
![alt text](image-69.png)

장점:
노드 장애가 발생해도 데이터 접근(가용성성)을 잃지 않을 수 있다.
    - 마스터 노드가 존재하지 않으므로
성능을 향상시키기 위해 노드를 쉽게 추가할 수 있다.

단점:
- **일관성 문제!**
    - 일관성 없는 **읽기**: 변경 사항이 다른 노드의 복사본으로 **느리게 전파**되어 **일관성** 없는 읽기가 발생할 수 있다.
하지만 이는 상대적으로 일시적이다 (즉, 영구적이지 않다). 내가 카카오톡에 프로필을 변경했더라도 다른사람들에게는 아주 잠깐동안지만 이전 프로필이 보일 수 있다. 이 불일치는 곧 해결된다.
**일관성 없는 쓰기**: 두 노드가 다른 노드에 저장된 동일한 레코드의 다른 복사본을 동시에 업데이트할 수 있다.
    - 일관성 없는 쓰기는 영구적이다.
    - 온라인 쇼핑몰에 재고가 하나 남은 상품을 동시에 두명이 구매한다면, 두명이 동시에 구매를 완료할 수 있다. 이때, 재고가 1개인 상품을 두명이 동시에 구매할 수 있다. 이는 일관성 문제가 발생한다.

# NoSql의 Consistency
 - RDBMS의 경우 ACID를 보장하므로 Consistency에 문제가 발생하지 않는다.
 - 그러나 NoSql의 경우 ACID를 보장하지 않으므로 데이터의 일관성에 문제가 발생하게 된다.
  
즉,
RDBMS: 강한 일관성을 보장하여 데이터의 일관성 문제가 발생하지 않는다.
NoSQL: 대부분 최종 일관성을 보장하며, 일시적으로 일관성 없는 상태가 될 수 있지만, 시간이 지나면 결국 일관성을 갖게된다.

## Confilicts
- Conflict possible if at least one operation is write: 적어도 하나의 작업이 쓰기 작업인 경우 충돌이 발생할 수 있다.

- Read-write conflict: 두 개의 논리적으로 관련된 쓰기 작업 사이에 읽기 작업이 발생할 때.

- Write-write conflict: 두 노드가 동시에 동일한 데이터 항목을 업데이트할 때.
- If the server serialize them: 서버가 이를 직렬화하면, 하나의 업데이트가 적용되고 즉시 다른 업데이트에 의해 덮어쓰여진다 (lost update). 즉, 직렬화 할 수 없다면 문제가된다 -> NoSql
  
![alt text](image-70.png)
- 마틴이라는 사람이 연필 5자루를 10자루인줄 알고 구매를 했을때, item_line에 연필 10자루의 정보와 , 지불 테이블에 연필 10자루의 데이터가 쓰여지게 된다.
- 그러나 마틴이 자신이 산게 연필 5자루인걸 알게되어, 지불 테이블에 연필 10자루의 가격을 5자루로 업데이트를 했는데, 이와 동시에 업데이트되기 이전에 Paramod라는 캐셔가 Line item과 Shipping Charge를 읽는 다면 Paramod는 마틴에게 10자루의 가격을 청구하게 되는 문제가 발생한다.
  
![alt text](image-71.png)
### Read-Write Conflict
`복제(replication)`는 `데이터 불일치`의 원인이 된다. 분산 시스템에서 특정 노드의 업데이트가 다른 노드에 즉시 반영되지 않아 `일관성` 문제가 발생할 수 있다.

### 상황 설명
1. **Mumbai 노드**: Pramod가 호텔의 마지막 방을 예약.
2. **London 노드**: 업데이트가 처리되지 않아 Martin은 여전히 방이 예약 가능하다고 봄 (불일치 읽기).
3. **Boston 노드**: Cindy는 방이 이미 예약된 상태를 확인.

### 문제점
- 복제가 지연되면서 여러 노드 간 데이터 상태가 달라짐.
- 사용자들이 일관되지 않은 데이터를 읽어 잘못된 결정을 내릴 수 있음.


## Solutions
### Pessimistic Approach
- 충돌 방지: `충돌이 발생하지 않도록` 예방한다.
- 쓰기 lock 사용: 시스템에서 관리하는 쓰기 lock 을 사용하여 구현한다.

### Optimistic Approach
- 충돌 허용 및 해결: `충돌이 발생하도록 허용`하지만, 이를 감지하고 해결하기 위한 조치를 취한다.
방법:
1. 조건부 업데이트: 업데이트 직전에 그 데이터를 검증한다.
2. 두 업데이트 모두 저장: 두 업데이트가 충돌 상태임을 기록하고 나중에 병합한다.

### Pesimistic vs Optimistic approach
#### Concurrency Trade-offs
- 동시성(Concurrency)은 두 가지 기본적인 트레이드오프를 포함한다.
  1. 안전성 (Safety)
     정의: 업데이트 충돌과 같은 오류를 피하는 것.
     목표: 데이터의 일관성을 유지하고, 충돌을 방지하는 것.

  2. 활성 상태 (Liveness)
     정의: 클라이언트에게 빠르게 응답하는 것.
     목표: 시스템의 응답성을 높이고, 지연 시간을 최소화하는 것.
#### Pessimistic Approaches
1. 시스템 응답성 저하
   정의: 시스템의 응답성을 심각하게 저하시킴. -> lock 시스템때문에
   원인: 높은 지연 시간(High Latency) 발생.

2. 교착 상태 (Deadlocks) 
   정의: 두 개 이상의 프로세스가 서로의 자원을 ()기다리며 무한 대기 상태에 빠지는 현상.
   문제점: 예방하고 디버깅하기 어려움.
   예 : 트랜잭션 A가 자원 X를 잠그고, 트랜잭션 B가 자원 Y를 잠갔는데, A가 Y를 요청하고 B가 X를 요청하면 두 트랜잭션 모두 멈추게 된다.

## Consistency Models
### Strong (or Immediate) Consistency
- 업데이트가 완료된 후, 모든 후속 접근은 업데이트된 값을 반환한다.
- RDBMS: ACID(Atomicity, Consistency, Isolation, Durability) 속성을 보장한다.

### Eventual Consistency
- 객체에 새로운 업데이트가 없으면, 모든 접근은 결국(after the inconsistency window closes) 마지막 업데이트된 값을 반환한다.
- inconsistency window: 데이터의 불일치가 존재하는 짧은 시간의 길이.
- 활성 상태 보장: 안전성 보장은 없지만, 활성 상태를 보장한다.
NoSQL: BASE(Basically Available, Soft state, Eventual consistent) 속성을 보장한다.

![alt text](image-72.png)
즉, Eventual Consistency에서
데이터의 비 일관성이 발생하여 지속되는 시간을 inconsistency window라고 하고 이후 일관성을 보장하게 된다.


### 요약
Strong Consistency: 업데이트가 완료된 후, 모든 후속 접근은 업데이트된 값을 반환.
Eventual Consistency: 새로운 업데이트가 없으면, 모든 접근은 결국 마지막 업데이트된 값을 반환.
Inconsistency Window: 데이터의 불일치가 존재하는 시간.
활성 상태 보장: 안전성 보장은 없지만, 활성 상태를 보장.
RDBMS: ACID 속성을 보장.
NoSQL: BASE 속성을 보장.


## Base properties
**Basically Available**
- 부분적으로 네트워크 장애가 발생해도 **요청에 대한 응답을 제공**한다(응답이 '실패'일 수 있음). 
  - 즉, Available이란 노드의 실패 방지에 대한 보장이 아니라, 노드가 실패했다면 실패했다고 다른 노드에 알려주어 다른 노드가 이를 대신할 수 있도록 하는것을 의미한다. 
- 일반적으로 복제 계수 = 3 으로, 1개의 노드가 실패해도 쿼리 응답이 가능하다.
  
**Soft State**
- 시스템은 시간이 지남에 따라 변경될 수 있다.
- 입력이 없는 동안에도 `"최종 일관성"`으로 인해 시스템 상태가 변경될 수 있다: 시스템 상태는 항상 "soft"하다.
  - 즉, 각 노드의 데이터나 상태의 전파 속도에 따라 현재 입력이나 작업이 없는 상태여도 각 노드의 상태가 변할 수 있음을 의미한다.
  
**Eventually Consistent**
모든 트랜잭션에 대해 일관성을 확인하지 않고 다음으로 넘어간다: 복제본이 일관되지 않을 수 있다.
"이후에" 데이터가 모든 곳으로 전파된다.

## Eventual Consistency: Facebook Example
![alt text](image-73.png)
내가 sns에 글이나 이미지를 작성하더라도 즉시 상대방에게 이게 보이지 않을 수 있다.
아마존의 경우 약 1초정도의 Inconcitency Window를 갖게 된다.
![alt text](image-74.png)

-> 페이스북이 eventual consistency model을 채택한 이유도 페이스북을 사용하는 엄청난 양의 유저들이 존재하기 때문에, 모든 유저들에게 즉시 데이터를 전파하는것은 불가능하고, 이때 발생하게 되는 Inconcitency Window는 무시될 수 있는 수준이기 때문에 이를 채택하게 된다.