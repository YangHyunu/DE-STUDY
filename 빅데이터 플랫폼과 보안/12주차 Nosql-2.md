
## Transactions on Nosql db
- Nosql db의 경우에도 ACID를 지원하려고 한다.
  - 다만 Aggragate Unit 내부의 데이터만 ACID가 보장되므로, 전체 데이터에 대한 ACID가 보장되기는 힘들다. 
  - 따라서, 여러개의 Aggregate의 데이터를 업데이트 한다면 데이터의 비일관성이 발생할 확률이 높아진다.

## Read-your-write consistency

- **뜻**:만약 내가 데이터를 업데이트 했다면, inconsistency window기간 안이더라도 업데이트 한 주체 즉, 나는 내가 업데이트한 데이터를 읽을 수 있어야 한다.
 - 한 마디로 sns에 내가 이미지를 올렸다면 즉시 내가 올린 이미지를 볼 수 있어야 함.
 - 만약 하나의 (웹) 세션이 지속되는 한 시스템은 write,read 일관성을 보장해야한다. 만약 업데이트 중 세션이 종료된다면 당연히 보장불가.
  
## Version Vector
 - 데이터의 Inconcitency 가 발생함을 **알려주는 역할**
 - Inconcitency를 해결하는 방법을 알려주지는 않는다.
 - 즉 업데이트 하기 전에, Version vector를 먼저 확인하여 데이터의 불일치 유무를 확인 한 후 업데이트를 하게 된다.

### Basic Operations

1. **초기 상태**
   - 모든 벡터 카운터는 0으로 초기화한다.

2. **로컬 업데이트 이벤트**
   - 복제본이 로컬 업데이트 이벤트를 경험할 때마다, 벡터에서 자신의 카운터를 1씩 증가시킨다.

3. **동기화**
   - 두 복제본 A와 B가 동기화될 때마다, 두 복제본은 벡터의 각 요소를 두 카운터 중   **최대값**으로 설정한다.
   - 동기화 후, 두 복제본은 `동일한 버전 벡터`를 갖게 된다.

--- 

## 복제본 A와 B의 비교: 버전 벡터 검사

## 예제: 버전 벡터
1. **동일한 상태로 시작**:  
   - 초기 상태: `A[2,3], B[2,3]`
   - 복제본 A와 B는 동일한 상태와 벡터를 가지고 있음.

2. **복제본 A가 업데이트됨**:  
   - 업데이트 후 상태: `A[3,3], B[2,3]`  
   - **A > B**: A는 더 많은 업데이트를 반영하였으므로 A가 B보다 최신임.

3. **복제본 A에 추가 업데이트 발생**:  
   - 업데이트 후 상태: `A[10,3], B[2,3]`  
   - A는 B보다 최신 상태를 유지하므로, 단순히 A의 상태를 B로 복사하여 동기화할 수 있음.

4. **복제본 B도 업데이트됨**:  
   - 업데이트 후 상태: `A[10,3], B[2,4]`  
   - 이제 A와 B는 **동시성 상태 (concurrent)**로, 동기화를 위해 추가적인 충돌 해결 작업이 필요함.  
   - 사용자 입력을 통해 적절한 상태로 조정하여 최종 벡터를 `[10,4]`로 동기화 가능.

---

## Identical (a == b)
- **정의**: 두 버전 벡터가 동일한 경우.
- **설명**: 모든 요소가 동일함.
- **예제**:  
  - `A[2,3] == B[2,3]`

## Ordered (a < b)
- **정의**: 모든 요소 Va가 해당하는 요소 Vb보다 작거나 같고, 적어도 하나의 요소가 엄격히 작은 경우.
- **설명**: a의 모든 요소가 b의 대응 요소보다 작거나 같으며, 최소 하나의 요소는 작음.
- **예제**:  
  - `A[3,3] < B[4,3]`

## Concurrent (a || b)
- **정의**: a < b도 아니고 a > b도 아니며, 벡터가 동일하지 않은 경우.
- **설명**: 두 벡터가 동일하지 않으며, 어느 한쪽이 다른 쪽보다 크거나 작지 않음.
  - 이때, 동기화를 위해 추가적인 충돌 해결 작업이 필요함. 즉, 동기화가 쉽지 않다.
    - > **Version Vector**가 이를 알려줌
- **예제**:  
  - `A[10,3] || B[2,4]`

---

## 요약
- **Identical (a == b)**: 두 버전 벡터가 동일함.
- **Ordered (a < b)**: 모든 요소 Va가 Vb보다 작거나 같고, 적어도 하나의 요소가 엄격히 작음. -> Sync를 맞추는데 수월하다
- **Concurrent (a || b)**: 두 벡터가 동일하지 않으며, 어느 한쪽이 다른 쪽보다 크거나 작지 않음. -> Sync를 맞추는데 어려움 및 충돌이 발생한다. -> **Version Vector**가 이를 알려줌
  - 즉 Concurrent 상태에서 동기화를 위해 추가적인 충돌 해결 작업이 필요함.
---
# Cap Theorem

![alt text](image-75.png)

![alt text](image-76.png)

CAP 정리 (CAP Theorem)

### 핵심 개념
- 불가능성: 분산 시스템이 동시에 다음 세 가지 보장을 모두 제공하는 것은 불가능하다.
  
- 선택: 분산 시스템은 이 세 가지 보장 중 두 가지를 만족시킬 수 있지만, 세 가지를 모두 만족시킬 수는 없다.

### 세 가지 보장

#### 일관성 (Consistency)
정의: 모든 노드가 동일한 데이터를 동시에 볼 수 있어야 한다.
설명: 데이터가 업데이트되면, 모든 노드가 즉시 그 변경 사항을 반영해야 한다.

#### 가용성 (Availability)

정의: 노드가 실패하더라도, 살아남은 노드들이 계속해서 작동할 수 있어야 한다.
설명: 시스템의 일부 노드가 다운되더라도, 시스템은 계속해서 요청에 응답할 수 있어야 한다.

#### 파티션 내성 (Partition Tolerance)

정의: **네트워크** 파티션이 발생하더라도 시스템이 계속해서 작동할 수 있어야 한다.
설명: 네트워크가 분할되어 일부 노드 간의 통신이 불가능해지더라도, 시스템은 계속해서 작동할 수 있어야 한다.

---

![alt text](image-129.png)

### 호텔 예약 시스템 예제

#### 시나리오
- Ann은 런던 노드를 통해 뉴욕에 있는 Ace Hotel의 방을 예약하려고 한다.
- Pramod는 뭄바이 노드를 통해 같은 방을 예약하려고 한다.
- 예약 시스템은 **피어 투 피어 분산 구조**를 사용한다.
- 호텔에는 **방이 단 하나**만 남아 있다.
- 두 노드 간의 **네트워크 연결이 끊어진다**.

---

### 가능한 해결책: CAP 이론 적용

#### 1. **CA (일관성과 가용성)**
- 두 사용자 모두 방을 예약할 수 없다.
- 일관성과 가용성을 유지하기 위해 네트워크 분할 허용성을 포기한다.

#### 2. **CP (일관성과 네트워크 분할 허용성)**
- 뭄바이 노드를 Ace Hotel의 마스터로 지정한다.
- Pramod는 예약에 성공한다.
- Ann은 방을 예약할 수 없다.
- 일관성을 유지하기 위해 가용성을 포기한다.

#### 3. **AP (가용성과 네트워크 분할 허용성)**
- 두 노드에서 모두 방 예약이 가능하다.
- 결과적으로 **중복 예약(Overbooking)**이 발생한다.
- 가용성과 네트워크 분할 허용성을 유지하기 위해 일관성을 포기한다.

---

### 고려 사항 및 문제
- 이러한 상황은 **도메인 특성**에 따라 다르다.
  - 예: 금융 거래, 블로그, 쇼핑 카트 등.
- 주요 질문:
  1. **오래된 데이터(stale reads)를 어느 정도 허용할 수 있는가?**
  2. **불일치 상태가 지속될 수 있는 시간은 얼마나 되는가?**

### 도메인별 상황 해결책

#### 1. **금융 거래**
- **해결책**: **CP (일관성과 네트워크 분할 허용성)**  
- **이유**: 금융 거래에서는 데이터의 **정확성(일관성)**이 가장 중요하다. 네트워크 분할이 발생하면 거래를 일시적으로 중단하더라도 일관성을 유지해야 한다. 잘못된 거래 기록은 치명적일 수 있기 때문이다.

---

#### 2. **블로그**
- **해결책**: **AP (가용성과 네트워크 분할 허용성)**  
- **이유**: 블로그 글 작성이나 댓글 달기는 가용성이 더 중요하다. 네트워크 분할 동안 일관성이 깨지더라도 사용자가 콘텐츠를 작성하고 읽을 수 있도록 허용하는 것이 사용자 경험에 더 유리하다.

---

#### 3. **쇼핑 카트**
- **해결책**: **AP (가용성과 네트워크 분할 허용성)** 또는 **CP (일관성과 네트워크 분할 허용성)**  
- **이유**:
  - **AP**는 사용자가 네트워크 상태와 관계없이 상품을 카트에 추가할 수 있도록 **가용성**을 우선시함함.
  - **CP**는 결제 과정에서 **일관성**을 유지하기 위해 네트워크 분할 시 서비스를 제한.
  - 쇼핑 카트 시스템은 일반적으로 **담기(AP)**와 **결제(CP)**를 서로 다른 CAP 전략으로 처리.

