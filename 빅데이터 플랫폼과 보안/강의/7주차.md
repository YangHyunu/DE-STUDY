
![image](https://github.com/user-attachments/assets/1f68ba73-de3a-495e-9f47-0ef986675d7c)


## Flajolet-Martin 알고리즘을 사용하는 이유
![image](https://github.com/user-attachments/assets/968d0e0d-e74e-4dd6-8133-2ea156297230)
- 실제 정답값을 m이라고 했을 때, FM 알고리즘을 사용해서 추정한 추정치가 m보다 작을 확률이 0 , 클 확률이 1이다.

따라서 우리의 추정치 2^R이 항상 m 근처에 있을 것이다.

![image](https://github.com/user-attachments/assets/901cfcbf-4637-48a1-85ff-700e658a2044)

1. 주어진 해시 값 h(a)h(a)가 최소한 rr개의 0으로 끝날 확률은 2−r2−r이다.

    해시 함수 h(a)h(a)는 특정 값을 무작위로 해시합니다.
    해시 값이 rr개의 0으로 끝날 확률은 2−r2−r입니다. 이는 무작위로 해시된 값이 rr개의 0으로 끝나는 경우가 확률적으로 1/2의 확률로 발생하기 때문입니다.
    예를 들어, 해시 값이 최소 1개의 0으로 끝날 확률은 2−1=1/22−1=1/2, 최소 2개의 0으로 끝날 확률은 2−2=1/42−2=1/4입니다.

2. mm개의 서로 다른 요소 중에서 길이가 rr인 꼬리를 찾지 못할 확률은 다음과 같습니다:

    여기서 말하는 "꼬리"는 해시 값이 최소한 rr개의 0으로 끝나는 것을 의미합니다.
    mm개의 고유한 요소 중에서 rr개의 0으로 끝나는 해시 값을 하나도 찾지 못할 확률을 구하는 방식입니다.
    개별 요소가 rr개의 0으로 끝나지 않을 확률은 1−2−r1−2−r입니다. 즉, 2−r2−r은 최소 rr개의 0으로 끝날 확률이므로, 이를 만족하지 않을 확률은 1−2−r1−2−r가 됩니다.

3. mm개의 요소 모두가 rr개의 0으로 끝나지 않을 확률:

    이제 mm개의 서로 다른 요소 중에서, 모두 rr개의 0으로 끝나지 않을 확률을 계산할 수 있습니다.
    각 요소가 rr개의 0으로 끝나지 않을 확률이 1−2−r1−2−r일 때, 이러한 확률이 mm개의 모든 요소에 대해 독립적으로 발생할 확률은 (1−2−r)m(1−2−r)m입니다.

따라서, mm개의 요소 중 어떤 요소도 rr개의 0으로 끝나지 않을 확률은 (1−2−r)m(1−2−r)m로 나타낼 수 있습니다.
결론:

    이 식은 스트림 내에서 mm개의 고유한 요소가 있을 때, 해시 값의 마지막이 rr개의 0으로 끝나는 요소를 발견하지 못할 확률을 나타냅니다.
    (1−2−r)m(1−2−r)m은 "모든 요소가 rr개의 0으로 끝나지 않는다"는 사건을 표현하며, 이는 해시 충돌이나 특정 패턴을 찾는 문제를 다룰 때 중요한 역할을 합니다.



![image](https://github.com/user-attachments/assets/40f21962-8aab-4572-aef0-a0663a6a73c0)




# Computing Moments

- 스트림의 요소가 N개의 값으로 구성된 집합 A에서 선택된다고 가정.
- 이때 , m_i는 값 i가 스트림에서 발생한 횟수로 정의되므로,
k번째 모멘트는
$$ \sum_{i \in A} (m_i^k) $$

#### Special Cases

- 0th moment = number of distinct elements<고유한 값들>

- 1st moment = count of the numbers of
elements = length of the stream

- 2nd moment = surprise number S =
a measure of how uneven the distribution is 

## 2nd moment는 빈도가 얼마나 균등한지(분포)를 확인하는데 사용됨!

### Example: Surprise Number

이 예시는 **Surprise Number**를 계산하는 방법을 설명합니다.

#### 조건
- **Stream of length 100**: 100개의 스트림 항목이 존재
- **11 distinct values**: 11개의 고유한 값이 존재

### 첫 번째 예시: `Item counts: 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9`

- 각 값의 빈도수는 다음과 같습니다:
  - 한 값은 10번 등장
  - 나머지 10개의 값은 각각 9번씩 등장
  
- **Surprise S = 910**
  - 계산: `10^2 + 10 * 9^2 = 100 + 810 = 910`

### 두 번째 예시: `Item counts: 90, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1`

- 각 값의 빈도수는 다음과 같습니다:
  - 한 값은 90번 등장
  - 나머지 10개의 값은 각각 1번씩 등장
  
- **Surprise S = 8,110**
  - 계산: `90^2 + 10 * 1^2 = 8100 + 10 = 8,110`


  AMS Method

    AMS 방법은 모든 차수(moment)에 대해 적용 가능합니다.
    하지만 여기서는 2차 모멘트 S에 집중합니다.

방법

    우리는 여러 변수를 선택하여 X라는 변수로 추적합니다.
    각 변수 X에 대해, X.el과 X.val을 저장합니다:
        X.el은 항목 i에 해당합니다.
        X.val은 항목 i의 개수를 나타냅니다.
    주의할 점은, 항목 개수를 메모리에 저장해야 하므로, 사용할 수 있는 X의 수는 제한이 있다는 것입니다.

목표

    우리의 목표는 S=∑imi2S=∑i​mi2​를 계산하는 것입니다.

이 방식은 2차 모멘트를 계산하기 위한 알고리즘을 구현하는 데 사용됩니다.




![alt text](image.png)

예제:

### Stream Information:
- **Stream**: `a, b, c, b, d, a, c, d, a, b, d, c, a, a, b
- **Stream length (n)**: 15
- **2차 모멘트**: 
  \[
  5^2 + 4^2 + 3^2 + 3^2 = 59
  \]
  - Occurrences:
    - `a`: 5 times
    - `b`: 4 times
    - `c`: 3 times
    - `d`: 3 times

### AMS Example:
- **Variables**: $$\( X_1, X_2, X_3 \)$$
- Random times \( t \) chosen: 3, 8, 13
- **Initialization**:
  - \( X_1.el = c \), \( X_1.val = 1 \)
  - \( X_2.el = d \), \( X_2.val = 1 \)
  - \( X_3.el = a \), \( X_3.val = 1 \)

x1에서 시작해서 자기 자신 이 나올때까지 무시하고 진행 => 자신을 발견하면 x1.val++ 
x2가 시작하면서 만약 x1을 발견한다면 x1++ x2를 발견할때까지 진행 x2.val++
x3가 시작하면 만약 x1을 발결한다면 x1.val++ ,x2를 발견한다면 x2.val++ 
x3가 마지막 변수이므로 주어진 스트림의 끝까지 진행 

### Example:

- **Stream**: `a, b, c, b, d, a, c, d, a, b, d, c, a, a, b`
- **Time** \( t = 1 \) to \( t = 15 \)

### AMS Example:

- **For \( X_1 \)**: Pick random time \( t < 15 \): 3
  - Initialization: \( X_1.el = c \), \( X_1.val = 1 \)
  - No update at 4th (b), 5th (d), and 6th (a) in the stream
  - At 7th (c), \( X_1 \) will update \( X_1.val = 2 \)

- **For \( X_2 \)**: Pick random time \( t < 15 \): 8
  - Initialization: \( X_2.el = d \), \( X_2.val = 1 \)
  - No update at 9th (a), 10th (b) in the stream
  - At 11th (d), \( X_2 \) will update \( X_2.val = 2 \)
  - At 12th (c), \( X_1 \) will update \( X_1.val = 3 \)

- **For \( X_3 \)**: Pick random time \( t < 15 \): 13
  - Initialization: \( X_3.el = a \), \( X_3.val = 1 \)
  - At 14th (a), \( X_3 \) will update \( X_3.val = 2 \)
  - No update at 15th (b) in the stream

### 2nd moment calculation:

- **Formula**: \( n(2 \cdot c \cdot c - 1) \), where \( c = X.val \)

  - \( X_1 \): \( 15(2 \cdot 3 \cdot 3 - 1) = 75 \)
  - \( X_2 \): \( 15(2 \cdot 2 \cdot 2 - 1) = 45 \)
  - \( X_3 \): \( 15(2 \cdot 2 \cdot 2 - 1) = 45 \)

- **Final estimation**:

$$
S = \frac{1}{3} (75 + 45 + 45) = 55
$$

- **Actual 2nd moment**: 59 (Fairly close approximation)


## AMS 예시 설명

### 스트림 데이터:
- 스트림: `a, b, c, b, d, a, c, d, a, b, d, c, a, a, b` (시간 \( t = 1 \) ~ \( t = 15 \))

### AMS 스케치 알고리즘:
1. **\( X_1 \)**: \( t = 3 \), \( X_1 \text{.el} = c \), 최종 값: \( X_1 \text{.val} = 2 \)
2. **\( X_2 \)**: \( t = 8 \), \( X_2 \text{.el} = d \), 최종 값: \( X_2 \text{.val} = 3 \)
3. **\( X_3 \)**: \( t = 13 \), \( X_3 \text{.el} = a \), 최종 값: \( X_3 \text{.val} = 2 \)

### 두 번째 순간 계산:
- \( n \cdot (2c - 1) \) 로 계산.
    - \( X_1: 75 \)
    - \( X_2: 45 \)
    - \( X_3: 45 \)

### 최종 추정:
- 추정값: \( \frac{1}{3} (75 + 45 + 45) = 55 \)
- 실제 값: 59 (근사치)


## 설명 요약

### 1. 두 번째 순간 \( S \):
- 각 항목의 등장 횟수 \( m_i \) 의 제곱 합을 계산합니다.
- 수식:  
  $$ S = \sum_i m_i^2 $$

### 2. \( c_t \) 정의:
- 시간 \( t \) 이후로 해당 항목이 등장한 횟수입니다.
- 예시: \( c_1 = m_a \), \( c_2 = m_a - 1 \), \( c_3 = m_b \), 등.

### 3. 기대값 \( E[f(X)] \):
- 시간 \( t \) 에서의 두 번째 순간 추정치:  
  $$ E[f(X)] = \frac{1}{n} \sum_{t=1}^{n} n(2c_t - 1) $$

### 4. 항목별 계산:
- 각 항목이 등장한 시점들을 그룹화하여 계산:  
  $$ = \frac{1}{n} \sum_i n (1 + 3 + 5 + \dots + 2m_i - 1) $$

### 5. 결론:
- 각 항목의 등장 횟수와 시점을 기반으로 두 번째 순간을 계산하여, 스트림에서 항목이 얼마나 자주 등장했는지를 추정할 수 있습니다.




### 문제점(한계)

stream의 크기를 \( n \)으로 가정한 후 알고리즘을 적용했는데, 데이터 스트림은 계속해서 들어오므로 \( n \)이 계속해서 커진다.

즉, 앞에서 \( n \)으로 정해 추정한 추정치는 뒤에 나오는 데이터에 대해 좋은 추정치로 사용할 수 없음을 의미한다.


### 문제 해결 방법 (Streams Never End: Fixups)

1. **변수 \( X \) 에서 \( n \) 이 포함된 경우**:
   - \( n \) 은 따로 보관하고, \( X \) 에는 개수만 저장하면 된다.

2. **저장할 수 있는 카운트가 \( k \) 개밖에 없을 때**:
   - 시간이 지나면서 일부 \( X \) 들을 버려야 한다.

#### 목표:
- 각 시작 시간 \( t \) 가 확률 \( \frac{k}{n} \) 로 선택되도록 한다.

#### 해결 방법 (고정 크기 샘플링):
- **처음 \( k \) 번의 시간**을 \( k \) 개 변수에 저장한다.
- **\( n \) 번째 항목이 도착했을 때**(즉, \( n > k \)), 이 항목을 확률 \( \frac{k}{n} \) 로 선택한다.
- 선택한 경우, **이전에 저장한 변수들 중 하나를 동일한 확률로 제거**한다.

# Finding frequent elements

![alt text](image-2.png)

### Counting Itemsets

#### 문제:
- 주어진 스트림에서 특정 항목이 윈도우에서 \( s \) 번 이상 등장하는지 확인하는 문제.

#### 가능한 해결책:
- 각 항목을 **이진 스트림**으로 변환해서 생각:
  - \( 1 \): 항목이 존재함
  - \( 0 \): 항목이 없음
- **DGIM 알고리즘**을 사용해 각 항목에 대한 \( 1 \)의 개수를 추정.

#### 설명:
- 스트림에서 항목이 등장할 때마다 \( 1 \) 로 표시되고, 그 구간을 버킷으로 묶어서 관리.
- **DGIM 알고리즘**은 스트림에서 \( 1 \) 이 나타나는 빈도를 추정할 때, 버킷 크기를 유지하면서 효율적으로 계산해줌.
- 위 그림에서는 스트림이 \( 1 \) 과 \( 0 \) 으로 구성된 이진 스트림 형태로 보여지며, \( N \) 개의 데이터가 스트림에 들어왔을 때 \( 1 \) 의 개수를 추정하는 과정을 나타냄.

### 확장 (Extensions)

#### 기본 원칙:
- 원칙적으로는 자주 등장하는 **쌍(pair)** 이나 더 큰 집합도 같은 방식으로 계산할 수 있음.
  - 항목 집합마다 하나의 스트림을 할당.
  - \( 1 \) 의 발생 횟수를 계산.

#### 단점 (Drawbacks):
- 결과는 **근사값**일 뿐임.
- **항목 집합의 수**가 너무 많아질 수 있음.
- **빈도만 고려**하고, **최근성**은 고려하지 않음.
  - 예를 들어, 최근에 등장한 항목에 더 높은 가중치를 주고 싶다면 어떻게 할지 고민해야 함.


### Exponentially Decaying Windows

#### 목적:
- 상황: `영화관에서 영화의 티켓을 카운팅 할때, 최근에 얼마나 많이 티켓이 팔렸는지를 구하는게 과거에서 부터 지금까지 팔린 티켓의 수를 구하는 것 보다 가치있음.`
- 자주 등장하는 항목을 선택하기 위한 **휴리스틱 방법**.
  - 현재 가장 인기 있는 항목을 찾기 위해 사용.
  - 단순히 최근 \( N \) 개 요소에서 빈도를 계산하는 대신, 전체 스트림에 대해 부드럽게 집계함.
  - 빈도뿐만 아니라 **최근성**도 고려.

#### 수식 설명:
- 스트림이 \( a_1, a_2, \dots \) 로 이루어져 있고, 시간 \( t \) 에서 스트림의 합을 구할 때:
  $$ \sum_{i=1}^{t} a_i (1 - c)^{t-i} $$
  - 여기서 \( c \) 는 매우 작은 상수 (예: \( 10^{-6} \) 또는 \( 10^{-9} \)).
  - 즉, `i가 커질 수록 과거의 값이 되고 가중치가 점점 작아지게됨.`
#### 새로운 항목 \( a_{t+1} \) 이 도착했을 때:
- 현재 합에 \( (1 - c) \) 를 곱하고, \( a_{t+1} \) 를 더해주면 됨.


### Example: Counting Items

#### 항목 계산 방법
- 각 \( a_i \) 를 "항목(item)"으로 간주하고, 각 가능한 항목 \( x \) 의 **특성 함수(characteristic function)** 를 지수적으로 감소하는 윈도우로 계산할 수 있음.

#### 수식:
- 특성 함수는 다음과 같이 계산됨:
  $$ \sum_{i=1}^{t} \delta_i \cdot (1 - c)^{t-i} $$
  - 여기서 \( \delta_i = 1 \) (항목 \( a_i \) 가 \( x \) 일 때), 그렇지 않으면 \( \delta_i = 0 \).
  
#### 설명:
- 각 항목 \( x \) 에 대해 이진 스트림을 생각:
  - \( 1 \): 항목 \( x \) 가 등장함.
  - \( 0 \): 항목 \( x \) 가 등장하지 않음.

#### 새로운 항목 \( x \) 가 도착했을 때:
1. 모든 카운트를 \( (1 - c) \) 로 곱함.
2. 항목 \( x \) 에 대해 카운트에 \( +1 \) 을 추가.

#### 핵심:
- **\( (1 - c) \)** 는 항목 \( x \) 의 가중치로 간주됨.

![alt text](image-3.png)
#### 유의해야 할 점은
가중치를 준 값의 합과 윈도우방식?으로 계산한 값들의 합은 반드시 같아야 한다.

![alt text](image-4.png)

### Example: Counting Items

1. **각 영화**는 별도의 스트림으로 가정한다면:
   - 영화 티켓이 나올 때마다 \( 1 \) 을 기록.
   - 다른 영화 티켓이 나오면 \( 0 \) 을 기록.

2. **인기도**는 그 영화에 대해 기록된 \( 1 \) 의 합을 지수적으로 감소시켜 계산.

3. **기준값(threshold)** 설정:
   - 예를 들어 \( 1/2 \) 을 기준값으로 설정하면,인기도 점수가 이 값보다 떨어지면 그 영화를 계산에서 제외.
   - 따라서 인기 없는 영화는 더 이상 기록하지 않음.

이 방식으로 불필요한 항목을 제거하고 중요한 항목만 관리할 수 있게 됨.

# 과제<논문>에서 한문제 나오는데
- 실험같은걸 보지말고
- 슬라이드를 올려주신거에서 main body만 보면 됀다.
- 겨우 한문제 나오는데 지엽적으로 나올거 걱정 X
- 이건, 나올 수 밖에 없다라고 생각하는 부분을 공부하면 OK

# O/X quiz
- 틀려도 점수를 깎지 않는다.
